// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: chats.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countChatsByUser = `-- name: CountChatsByUser :one
select count(*) from chats
where created_by = $1
`

func (q *Queries) CountChatsByUser(ctx context.Context, createdBy pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countChatsByUser, createdBy)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChat = `-- name: CreateChat :one
insert into chats (
  title,
  created_by
) values (
  $1, $2
)
returning id, title, created_at, updated_at, created_by
`

type CreateChatParams struct {
	Title     pgtype.Text
	CreatedBy pgtype.Text
}

func (q *Queries) CreateChat(ctx context.Context, arg CreateChatParams) (Chat, error) {
	row := q.db.QueryRow(ctx, createChat, arg.Title, arg.CreatedBy)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const createChatMessage = `-- name: CreateChatMessage :one
insert into chat_messages (
  chat_id,
  choices,
  object,
  model
) values (
  $1, $2, $3, $4
)
returning id, chat_id, choices, object, model, created_at
`

type CreateChatMessageParams struct {
	ChatID  pgtype.UUID
	Choices []byte
	Object  string
	Model   pgtype.Text
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.ChatID,
		arg.Choices,
		arg.Object,
		arg.Model,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.Choices,
		&i.Object,
		&i.Model,
		&i.CreatedAt,
	)
	return i, err
}

const deleteChat = `-- name: DeleteChat :exec
delete from chats
where id = $1
and created_by = $2
`

type DeleteChatParams struct {
	ID        pgtype.UUID
	CreatedBy pgtype.Text
}

func (q *Queries) DeleteChat(ctx context.Context, arg DeleteChatParams) error {
	_, err := q.db.Exec(ctx, deleteChat, arg.ID, arg.CreatedBy)
	return err
}

const getChatMessages = `-- name: GetChatMessages :many
select id, chat_id, choices, object, model, created_at from chat_messages
where chat_id = $1
order by created_at asc
`

func (q *Queries) GetChatMessages(ctx context.Context, chatID pgtype.UUID) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, getChatMessages, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.Choices,
			&i.Object,
			&i.Model,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatWithMessages = `-- name: GetChatWithMessages :many
select 
  c.id, c.title, c.created_at, c.updated_at, c.created_by,
  m.id as message_id,
  m.choices,
  m.object,
  m.model,
  m.created_at as message_created_at
from chats c
left join chat_messages m on c.id = m.chat_id
where c.id = $1
order by m.created_at asc
`

type GetChatWithMessagesRow struct {
	ID               pgtype.UUID
	Title            pgtype.Text
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
	CreatedBy        pgtype.Text
	MessageID        pgtype.UUID
	Choices          []byte
	Object           pgtype.Text
	Model            pgtype.Text
	MessageCreatedAt pgtype.Timestamptz
}

func (q *Queries) GetChatWithMessages(ctx context.Context, id pgtype.UUID) ([]GetChatWithMessagesRow, error) {
	rows, err := q.db.Query(ctx, getChatWithMessages, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatWithMessagesRow
	for rows.Next() {
		var i GetChatWithMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.MessageID,
			&i.Choices,
			&i.Object,
			&i.Model,
			&i.MessageCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatsByUser = `-- name: ListChatsByUser :many
select id, title, created_at, updated_at, created_by from chats
where created_by = $1
order by updated_at desc
limit $2 offset $3
`

type ListChatsByUserParams struct {
	CreatedBy pgtype.Text
	Limit     int32
	Offset    int32
}

func (q *Queries) ListChatsByUser(ctx context.Context, arg ListChatsByUserParams) ([]Chat, error) {
	rows, err := q.db.Query(ctx, listChatsByUser, arg.CreatedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chat
	for rows.Next() {
		var i Chat
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChatMessage = `-- name: UpdateChatMessage :one
update chat_messages
set choices = $2
where id = $1
and chat_id = $3
returning id, chat_id, choices, object, model, created_at
`

type UpdateChatMessageParams struct {
	ID      pgtype.UUID
	Choices []byte
	ChatID  pgtype.UUID
}

func (q *Queries) UpdateChatMessage(ctx context.Context, arg UpdateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, updateChatMessage, arg.ID, arg.Choices, arg.ChatID)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.Choices,
		&i.Object,
		&i.Model,
		&i.CreatedAt,
	)
	return i, err
}

const updateChatTitle = `-- name: UpdateChatTitle :one
update chats
set title = $2
where id = $1
and created_by = $3
returning id, title, created_at, updated_at, created_by
`

type UpdateChatTitleParams struct {
	ID        pgtype.UUID
	Title     pgtype.Text
	CreatedBy pgtype.Text
}

func (q *Queries) UpdateChatTitle(ctx context.Context, arg UpdateChatTitleParams) (Chat, error) {
	row := q.db.QueryRow(ctx, updateChatTitle, arg.ID, arg.Title, arg.CreatedBy)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}
