// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: chats.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countChatsByUser = `-- name: CountChatsByUser :one
select count(*) from chats
where created_by = $1
and organization_id = $2
`

type CountChatsByUserParams struct {
	CreatedBy      pgtype.Text
	OrganizationID pgtype.Text
}

func (q *Queries) CountChatsByUser(ctx context.Context, arg CountChatsByUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, countChatsByUser, arg.CreatedBy, arg.OrganizationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChat = `-- name: CreateChat :one
insert into chats (
  id, 
  title,
  created_by,
  organization_id
) values (
  $1, $2, $3, $4
)
returning id, title, visibility, organization_id, created_at, updated_at, created_by
`

type CreateChatParams struct {
	ID             string
	Title          pgtype.Text
	CreatedBy      pgtype.Text
	OrganizationID pgtype.Text
}

func (q *Queries) CreateChat(ctx context.Context, arg CreateChatParams) (Chat, error) {
	row := q.db.QueryRow(ctx, createChat,
		arg.ID,
		arg.Title,
		arg.CreatedBy,
		arg.OrganizationID,
	)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Visibility,
		&i.OrganizationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const createChatMessage = `-- name: CreateChatMessage :one
insert into chat_messages (
  chat_id,
  choices,
  object,
  model,
  created_at
) values (
  $1, $2, $3, $4, $5
)
returning id, chat_id, choices, object, model, created_at
`

type CreateChatMessageParams struct {
	ChatID    string
	Choices   []byte
	Object    string
	Model     pgtype.Text
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.ChatID,
		arg.Choices,
		arg.Object,
		arg.Model,
		arg.CreatedAt,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.Choices,
		&i.Object,
		&i.Model,
		&i.CreatedAt,
	)
	return i, err
}

const deleteChat = `-- name: DeleteChat :exec
delete from chats
where id = $1
and created_by = $2
and organization_id = $3
`

type DeleteChatParams struct {
	ID             string
	CreatedBy      pgtype.Text
	OrganizationID pgtype.Text
}

func (q *Queries) DeleteChat(ctx context.Context, arg DeleteChatParams) error {
	_, err := q.db.Exec(ctx, deleteChat, arg.ID, arg.CreatedBy, arg.OrganizationID)
	return err
}

const getChatById = `-- name: GetChatById :one
select id, title, visibility, organization_id, created_at, updated_at, created_by from chats
where id = $1
`

func (q *Queries) GetChatById(ctx context.Context, id string) (Chat, error) {
	row := q.db.QueryRow(ctx, getChatById, id)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Visibility,
		&i.OrganizationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getChatMessages = `-- name: GetChatMessages :many
select id, chat_id, choices, object, model, created_at from chat_messages
where chat_id = $1
order by created_at asc
`

func (q *Queries) GetChatMessages(ctx context.Context, chatID string) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, getChatMessages, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.Choices,
			&i.Object,
			&i.Model,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatWithMessages = `-- name: GetChatWithMessages :many
select 
  c.id, c.title, c.visibility, c.organization_id, c.created_at, c.updated_at, c.created_by,
  m.id as message_id,
  m.choices,
  m.object,
  m.model,
  m.created_at as message_created_at
from chats c
left join chat_messages m on c.id = m.chat_id
where c.id = $1
order by m.created_at asc
`

type GetChatWithMessagesRow struct {
	ID               string
	Title            pgtype.Text
	Visibility       NullChatVisibility
	OrganizationID   pgtype.Text
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
	CreatedBy        pgtype.Text
	MessageID        pgtype.UUID
	Choices          []byte
	Object           pgtype.Text
	Model            pgtype.Text
	MessageCreatedAt pgtype.Timestamptz
}

func (q *Queries) GetChatWithMessages(ctx context.Context, id string) ([]GetChatWithMessagesRow, error) {
	rows, err := q.db.Query(ctx, getChatWithMessages, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatWithMessagesRow
	for rows.Next() {
		var i GetChatWithMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Visibility,
			&i.OrganizationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.MessageID,
			&i.Choices,
			&i.Object,
			&i.Model,
			&i.MessageCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChatsByUser = `-- name: ListChatsByUser :many
select id, title, visibility, organization_id, created_at, updated_at, created_by from chats
where created_by = $1
and organization_id = $2
order by updated_at desc
limit $3 offset $4
`

type ListChatsByUserParams struct {
	CreatedBy      pgtype.Text
	OrganizationID pgtype.Text
	Limit          int32
	Offset         int32
}

func (q *Queries) ListChatsByUser(ctx context.Context, arg ListChatsByUserParams) ([]Chat, error) {
	rows, err := q.db.Query(ctx, listChatsByUser,
		arg.CreatedBy,
		arg.OrganizationID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chat
	for rows.Next() {
		var i Chat
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Visibility,
			&i.OrganizationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChatMessage = `-- name: UpdateChatMessage :one
update chat_messages
set choices = $2
where id = $1
and chat_id = $3
returning id, chat_id, choices, object, model, created_at
`

type UpdateChatMessageParams struct {
	ID      pgtype.UUID
	Choices []byte
	ChatID  string
}

func (q *Queries) UpdateChatMessage(ctx context.Context, arg UpdateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, updateChatMessage, arg.ID, arg.Choices, arg.ChatID)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.Choices,
		&i.Object,
		&i.Model,
		&i.CreatedAt,
	)
	return i, err
}

const updateChatTitle = `-- name: UpdateChatTitle :one
update chats
set title = $2
where id = $1
and created_by = $3
returning id, title, visibility, organization_id, created_at, updated_at, created_by
`

type UpdateChatTitleParams struct {
	ID        string
	Title     pgtype.Text
	CreatedBy pgtype.Text
}

func (q *Queries) UpdateChatTitle(ctx context.Context, arg UpdateChatTitleParams) (Chat, error) {
	row := q.db.QueryRow(ctx, updateChatTitle, arg.ID, arg.Title, arg.CreatedBy)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Visibility,
		&i.OrganizationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const updateChatVisibility = `-- name: UpdateChatVisibility :one
update chats
set
  visibility = $2
where id = $1 and created_by = $3
returning id, title, visibility, organization_id, created_at, updated_at, created_by
`

type UpdateChatVisibilityParams struct {
	ID         string
	Visibility NullChatVisibility
	CreatedBy  pgtype.Text
}

func (q *Queries) UpdateChatVisibility(ctx context.Context, arg UpdateChatVisibilityParams) (Chat, error) {
	row := q.db.QueryRow(ctx, updateChatVisibility, arg.ID, arg.Visibility, arg.CreatedBy)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Visibility,
		&i.OrganizationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}
