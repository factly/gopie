// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: downloads.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDownload = `-- name: CreateDownload :one
INSERT INTO downloads (
    dataset_id,
    user_id,
    org_id,
    sql,
    "format"
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, sql, dataset_id, status, format, pre_signed_url, error_message, created_at, updated_at, expires_at, completed_at, user_id, org_id
`

type CreateDownloadParams struct {
	DatasetID string
	UserID    string
	OrgID     string
	Sql       string
	Format    string
}

func (q *Queries) CreateDownload(ctx context.Context, arg CreateDownloadParams) (Download, error) {
	row := q.db.QueryRow(ctx, createDownload,
		arg.DatasetID,
		arg.UserID,
		arg.OrgID,
		arg.Sql,
		arg.Format,
	)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.Sql,
		&i.DatasetID,
		&i.Status,
		&i.Format,
		&i.PreSignedUrl,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.CompletedAt,
		&i.UserID,
		&i.OrgID,
	)
	return i, err
}

const deleteDownload = `-- name: DeleteDownload :exec
DELETE FROM downloads
WHERE id = $1 AND org_id = $2
`

type DeleteDownloadParams struct {
	ID    pgtype.UUID
	OrgID string
}

func (q *Queries) DeleteDownload(ctx context.Context, arg DeleteDownloadParams) error {
	_, err := q.db.Exec(ctx, deleteDownload, arg.ID, arg.OrgID)
	return err
}

const getDownload = `-- name: GetDownload :one
SELECT id, sql, dataset_id, status, format, pre_signed_url, error_message, created_at, updated_at, expires_at, completed_at, user_id, org_id FROM downloads
WHERE id = $1 AND org_id = $2
`

type GetDownloadParams struct {
	ID    pgtype.UUID
	OrgID string
}

func (q *Queries) GetDownload(ctx context.Context, arg GetDownloadParams) (Download, error) {
	row := q.db.QueryRow(ctx, getDownload, arg.ID, arg.OrgID)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.Sql,
		&i.DatasetID,
		&i.Status,
		&i.Format,
		&i.PreSignedUrl,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.CompletedAt,
		&i.UserID,
		&i.OrgID,
	)
	return i, err
}

const listDownloadsByUser = `-- name: ListDownloadsByUser :many
SELECT id, sql, dataset_id, status, format, pre_signed_url, error_message, created_at, updated_at, expires_at, completed_at, user_id, org_id FROM downloads
WHERE user_id = $1 AND org_id = $2
ORDER BY created_at DESC
LIMIT $3
OFFSET $4
`

type ListDownloadsByUserParams struct {
	UserID string
	OrgID  string
	Limit  int32
	Offset int32
}

func (q *Queries) ListDownloadsByUser(ctx context.Context, arg ListDownloadsByUserParams) ([]Download, error) {
	rows, err := q.db.Query(ctx, listDownloadsByUser,
		arg.UserID,
		arg.OrgID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Download
	for rows.Next() {
		var i Download
		if err := rows.Scan(
			&i.ID,
			&i.Sql,
			&i.DatasetID,
			&i.Status,
			&i.Format,
			&i.PreSignedUrl,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.CompletedAt,
			&i.UserID,
			&i.OrgID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingDownloads = `-- name: ListPendingDownloads :many
SELECT id, sql, dataset_id, status, format, pre_signed_url, error_message, created_at, updated_at, expires_at, completed_at, user_id, org_id FROM downloads
WHERE status = 'pending'
ORDER BY created_at ASC
FOR UPDATE SKIP LOCKED
`

func (q *Queries) ListPendingDownloads(ctx context.Context) ([]Download, error) {
	rows, err := q.db.Query(ctx, listPendingDownloads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Download
	for rows.Next() {
		var i Download
		if err := rows.Scan(
			&i.ID,
			&i.Sql,
			&i.DatasetID,
			&i.Status,
			&i.Format,
			&i.PreSignedUrl,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.CompletedAt,
			&i.UserID,
			&i.OrgID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDownloadAsCompleted = `-- name: SetDownloadAsCompleted :one
UPDATE downloads
SET
    status = 'completed',
    pre_signed_url = $2,
    completed_at = now(),
    updated_at = now(),
    expires_at = $3
WHERE id = $1
RETURNING id, sql, dataset_id, status, format, pre_signed_url, error_message, created_at, updated_at, expires_at, completed_at, user_id, org_id
`

type SetDownloadAsCompletedParams struct {
	ID           pgtype.UUID
	PreSignedUrl pgtype.Text
	ExpiresAt    pgtype.Timestamptz
}

func (q *Queries) SetDownloadAsCompleted(ctx context.Context, arg SetDownloadAsCompletedParams) (Download, error) {
	row := q.db.QueryRow(ctx, setDownloadAsCompleted, arg.ID, arg.PreSignedUrl, arg.ExpiresAt)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.Sql,
		&i.DatasetID,
		&i.Status,
		&i.Format,
		&i.PreSignedUrl,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.CompletedAt,
		&i.UserID,
		&i.OrgID,
	)
	return i, err
}

const setDownloadAsFailed = `-- name: SetDownloadAsFailed :one
UPDATE downloads
SET
    status = 'failed',
    error_message = $2,
    completed_at = now(),
    updated_at = now()
WHERE id = $1
RETURNING id, sql, dataset_id, status, format, pre_signed_url, error_message, created_at, updated_at, expires_at, completed_at, user_id, org_id
`

type SetDownloadAsFailedParams struct {
	ID           pgtype.UUID
	ErrorMessage pgtype.Text
}

func (q *Queries) SetDownloadAsFailed(ctx context.Context, arg SetDownloadAsFailedParams) (Download, error) {
	row := q.db.QueryRow(ctx, setDownloadAsFailed, arg.ID, arg.ErrorMessage)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.Sql,
		&i.DatasetID,
		&i.Status,
		&i.Format,
		&i.PreSignedUrl,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.CompletedAt,
		&i.UserID,
		&i.OrgID,
	)
	return i, err
}

const setDownloadToProcessing = `-- name: SetDownloadToProcessing :one
UPDATE downloads
SET
    status = 'processing',
    updated_at = now()
WHERE id = $1
RETURNING id, sql, dataset_id, status, format, pre_signed_url, error_message, created_at, updated_at, expires_at, completed_at, user_id, org_id
`

func (q *Queries) SetDownloadToProcessing(ctx context.Context, id pgtype.UUID) (Download, error) {
	row := q.db.QueryRow(ctx, setDownloadToProcessing, id)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.Sql,
		&i.DatasetID,
		&i.Status,
		&i.Format,
		&i.PreSignedUrl,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.CompletedAt,
		&i.UserID,
		&i.OrgID,
	)
	return i, err
}
