"use client";

import { useState, useEffect } from "react";
import { toast } from "sonner";
import { LinkIcon, Download, X, CheckCircle } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Progress } from "@/components/ui/progress";
import { cn } from "@/lib/utils";
import { UploadConfirmationDialog } from "./upload-confirmation-dialog";
import Uppy, { UppyFile, Meta } from "@uppy/core";
import AwsS3 from "@uppy/aws-s3";
import {
  validateFileWithDuckDb,
  ValidationResult,
  convertFileWithTypes,
  detectFileFormat,
  getFileFormatDisplay,
  SupportedFileFormat,
} from "@/lib/validation/validate-file";
import { useDuckDb } from "@/hooks/useDuckDb";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle, CheckCircle2, AlertTriangle } from "lucide-react";
import { useColumnNameStore } from "@/lib/stores/columnNameStore";
import { useColumnDescriptionStore } from "@/lib/stores/columnDescriptionStore";
import { ColumnNameEditor } from "@/components/dataset/column-name-editor";
import { useUploadStore } from "@/lib/stores/uploadStore";

interface UrlUploaderProps {
  projectId: string;
  onUploadSuccess?: (
    file: UppyFile<Meta, Record<string, never>>,
    response: unknown,
    validation: ValidationResult
  ) => void;
  onUploadError?: (error: string) => void;
  onAutoGenerateDescriptions?: (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    summary: Record<string, any>,
    rows: string[][]
  ) => Promise<void>;
  onValidationSuccess?: () => void;
  className?: string;
}

export function UrlUploader({
  projectId,
  onUploadSuccess,
  onAutoGenerateDescriptions,
  onValidationSuccess,
  className,
}: UrlUploaderProps) {
  const [url, setUrl] = useState("");
  const [isUploading, setIsUploading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [uppy, setUppy] = useState<Uppy | null>(null);
  const [isConfirmDialogOpen, setIsConfirmDialogOpen] = useState(false);
  const [urlError, setUrlError] = useState<string | null>(null);
  const [downloadedFile, setDownloadedFile] = useState<File | null>(null);
  const [modifiedFile, setModifiedFile] = useState<File | null>(null);
  const [detectedFormat, setDetectedFormat] = useState<SupportedFileFormat | null>(null);
  const [validationResult, setValidationResult] = useState<ValidationResult | null>(null);

  // DuckDB integration
  const { db, isInitialized, isInitializing, error: duckDbError } = useDuckDb();

  // Column name store integration
  const columnMappings = useColumnNameStore((state) => state.columnMappings);
  const setColumnMappings = useColumnNameStore((state) => state.setColumnMappings);
  const setProjectId = useColumnNameStore((state) => state.setProjectId);
  const resetColumnMappings = useColumnNameStore((state) => state.resetColumnMappings);
  const getColumnMappings = useColumnNameStore((state) => state.getColumnMappings);
  const getColumnDataTypes = useColumnNameStore((state) => state.getColumnDataTypes);
  const hasDataTypeChanges = useColumnNameStore((state) => state.hasDataTypeChanges);

  // Column description store integration
  const clearColumnDescriptions = useColumnDescriptionStore((state) => state.clearColumnDescriptions);
  
  // Upload store integration for filename tracking
  const setOriginalFileName = useUploadStore((state) => state.setOriginalFileName);

  // Calculate if all column names are valid
  const allColumnsValid = Object.values(columnMappings).every(
    (mapping) => mapping.isValid
  );
  const canUpload =
    (downloadedFile !== null || modifiedFile !== null) &&
    allColumnsValid &&
    validationResult?.isValid === true;

  // Initialize Uppy instance
  useEffect(() => {
    const uppyInstance = new Uppy({
      id: "url-uploader",
      restrictions: {
        maxNumberOfFiles: 1,
      },
      autoProceed: false,
      allowMultipleUploads: false,
    });

    uppyInstance.use(AwsS3, {
      endpoint:
        process.env.NEXT_PUBLIC_COMPANION_URL || "http://localhost:3020",
    });

    // Handle upload progress
    uppyInstance.on("upload-progress", (file, progressData) => {
      const bytesTotal = progressData.bytesTotal || 0;
      if (bytesTotal > 0) {
        setProgress(
          Math.round((progressData.bytesUploaded / bytesTotal) * 100)
        );
      }
    });

    // Handle upload start
    uppyInstance.on("upload", () => {
      setIsUploading(true);
    });

    // Handle upload success
    uppyInstance.on("upload-success", async (file, response) => {
      try {
        if (onUploadSuccess && file) {
          // Use the current validation result or create a basic one if not available
          const currentValidation = validationResult || {
            isValid: true,
            format: detectedFormat || 'csv',
            columnNames: [],
            columnTypes: [],
            previewData: []
          };
          onUploadSuccess(file, response, currentValidation);
        }

        toast.success("File from URL uploaded successfully!");

        // Reset states
        setUrl("");
        setProgress(0);
        setIsUploading(false);
        setUrlError(null);
        setDownloadedFile(null);
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : "Unknown error";
        setUrlError(`Upload success handler failed: ${errorMessage}`);
        toast.error(`Upload success handler failed: ${errorMessage}`);
      }
    });

    // Handle upload error
    uppyInstance.on("upload-error", (file, error) => {
      setUrlError(error.message);
      toast.error(`Upload failed: ${error.message}`);
      setIsUploading(false);
    });

    setUppy(uppyInstance);

    // Clean up function
    return () => {
      uppyInstance.cancelAll();
    };
  }, [onUploadSuccess, detectedFormat, validationResult]);

  // Set project ID in store when component mounts or project ID changes
  useEffect(() => {
    setProjectId(projectId);

    // Reset state when component unmounts
    return () => {
      resetColumnMappings();
      clearColumnDescriptions();
      setDownloadedFile(null);
      setModifiedFile(null);
      setValidationResult(null);
      setUrlError(null);
      setDetectedFormat(null);
      setUrl("");
      if (uppy) {
        uppy.cancelAll();
      }
    };
  }, [projectId, clearColumnDescriptions, resetColumnMappings, setProjectId, uppy]);

  // Process datatype changes immediately when they happen (only for CSV files)
  const handleDataTypeChange = async () => {
    if (!db || !downloadedFile || !isInitialized) {
      toast.error("DuckDB is not initialized or no file selected");
      return;
    }

    // Only support datatype conversion for CSV files
    if (detectedFormat !== "csv") {
      toast.info(
        `Datatype conversion is only supported for CSV files. ${getFileFormatDisplay(
          detectedFormat || "csv"
        )} files will be uploaded as-is.`
      );
      return;
    }

    if (!hasDataTypeChanges()) {
      // If no datatype changes, nothing to do
      return;
    }

    try {
      // Get column mappings and data types
      const mappings = getColumnMappings();
      const dataTypes = getColumnDataTypes();

      // Read the original file as ArrayBuffer
      const buffer = await downloadedFile.arrayBuffer();

      // Show processing toast
      toast.loading("Processing datatypes with DuckDB...", {
        id: "process-datatypes",
      });

      // Convert the file with updated datatypes
      const convertedBuffer = await convertFileWithTypes(
        db,
        buffer,
        downloadedFile.name,
        mappings,
        dataTypes
      );

      // Create a new File from the converted buffer
      const newFile = new File(
        [convertedBuffer],
        `converted_${downloadedFile.name}`,
        { type: downloadedFile.type }
      );

      // Update state with the new file
      setModifiedFile(newFile);

      toast.success("File processed with updated datatypes!", {
        id: "process-datatypes",
      });
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";
      toast.error(`Error processing datatypes: ${errorMessage}`, {
        id: "process-datatypes",
      });
      setUrlError(`Error processing datatypes: ${errorMessage}`);
    }
  };

  const isValidUrl = (urlString: string): boolean => {
    try {
      const url = new URL(urlString);
      return url.protocol === "http:" || url.protocol === "https:";
    } catch {
      return false;
    }
  };

  const getFilenameFromUrl = (urlString: string): string => {
    try {
      const url = new URL(urlString);
      const pathname = url.pathname;
      const filename = pathname.split("/").pop() || "dataset";
      return filename.includes(".") ? filename : `${filename}.csv`;
    } catch {
      return "dataset.csv";
    }
  };

  const downloadFileFromUrl = async (url: string): Promise<File> => {
    // Use our proxy API to avoid CORS issues
    const response = await fetch("/api/proxy-url", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ url }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
    }

    const blob = await response.blob();
    const filename = getFilenameFromUrl(url);
    const contentType = response.headers.get("content-type") || "text/csv";
    
    return new File([blob], filename, { type: contentType });
  };

  const handleAddUrl = async () => {
    if (!url.trim()) {
      toast.error("Please enter a URL");
      return;
    }

    if (!isValidUrl(url)) {
      toast.error("Please enter a valid HTTP or HTTPS URL");
      return;
    }

    // Reset states
    setUrlError(null);
    setProgress(0);
    setDownloadedFile(null);
    setModifiedFile(null);
    setValidationResult(null);
    setDetectedFormat(null);
    resetColumnMappings();
    clearColumnDescriptions();

    try {
      // Show download progress
      toast.loading("Downloading file from URL...", { id: "download-url" });

      // Download the file
      const file = await downloadFileFromUrl(url);
      setDownloadedFile(file);
      setOriginalFileName(file.name);

      // Detect file format
      const format = detectFileFormat(file.name, file.type);
      setDetectedFormat(format);

      toast.success("File downloaded successfully!", { id: "download-url" });

      if (!format) {
        setUrlError("Unsupported file format");
        return;
      }

      // Validate file with DuckDB if available
      if (!isInitialized || !db) {
        toast.warning(
          `DuckDB is not initialized for validation. ${getFileFormatDisplay(
            format
          )} file will be uploaded without validation.`
        );
        // Set basic validation result
        setValidationResult({
          isValid: true,
          format,
          error: "Validation skipped - DuckDB not available",
        });
        return;
      }

      try {
        const fileSize = file.size;

        // Skip detailed validation for files > 1GB
        if (fileSize > 1000 * 1000 * 1000) {
          setValidationResult({
            isValid: true,
            format,
            error: `File is larger than 1GB. Will be uploaded and validated on the server.`,
          });
          toast.info(
            `Large ${getFileFormatDisplay(
              format
            )} file detected. Client-side validation skipped, will validate on server.`
          );
          return;
        }

        // Read file as ArrayBuffer for validation
        const buffer = await file.arrayBuffer();

        // Validate file with DuckDB
        const result = await validateFileWithDuckDb(
          db,
          buffer,
          file.name,
          fileSize,
          file.type
        );
        setValidationResult(result);

        if (!result.isValid) {
          toast.error(
            `${getFileFormatDisplay(format)} validation failed: ${result.error}`
          );
        } else {
          toast.success(`${getFileFormatDisplay(format)} validation successful!`);

          // If validation successful and we have column names, update the column name store
          if (result.columnNames) {
            setColumnMappings(result.columnNames, result.columnTypes);

            // Auto-generate column descriptions if callback is provided (only for tabular formats)
            if (
              onAutoGenerateDescriptions &&
              result.previewData &&
              ["csv", "parquet", "excel"].includes(format)
            ) {
              // Helper function to safely convert BigInt and other types to serializable values
              const serializeValue = (value: unknown): unknown => {
                if (typeof value === "bigint") {
                  return value.toString();
                }
                if (value instanceof Date) {
                  return value.toISOString();
                }
                if (Array.isArray(value)) {
                  return value.map(serializeValue);
                }
                if (value && typeof value === "object") {
                  const serialized: Record<string, unknown> = {};
                  for (const [key, val] of Object.entries(value)) {
                    serialized[key] = serializeValue(val);
                  }
                  return serialized;
                }
                return value;
              };

              // Create summary from validation result using updated column names
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              const summary: Record<string, any> = {};
              result.columnNames.forEach((originalName, index) => {
                // Get the updated name for this column (it will be the same initially)
                const mapping = Object.values(columnMappings).find(
                  (m) => m.originalName === originalName
                );
                const updatedName = mapping?.updatedName || originalName;

                summary[updatedName] = {
                  type: result.columnTypes?.[index] || "string",
                  count: result.previewRowCount || 0,
                };
              });

              // Serialize the preview data to handle BigInt and other non-JSON types
              const serializedRows = serializeValue(
                result.previewData
              ) as string[][];

              // Use preview data as sample rows (non-blocking)
              onAutoGenerateDescriptions(summary, serializedRows).catch(
                (error) => {
                  console.error("Auto-generation failed:", error);
                  // Don't let auto-generation errors affect the file upload flow
                }
              );
            }
          }
          
          // Call validation success callback if provided
          if (onValidationSuccess) {
            onValidationSuccess();
          }
        }
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : "Unknown error";
        setUrlError(
          `Error processing ${getFileFormatDisplay(format)} file: ${errorMessage}`
        );
        toast.error(
          `Error processing ${getFileFormatDisplay(format)} file: ${errorMessage}`
        );
      }
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";
      setUrlError(`Failed to download file: ${errorMessage}`);
      toast.error(`Failed to download file: ${errorMessage}`, {
        id: "download-url",
      });
    }
  };

  const handleConfirmUpload = async (
    datasetName: string,
    description: string
  ) => {
    if (!uppy || (!downloadedFile && !modifiedFile) || !canUpload) {
      toast.error("Please fix all validation errors before uploading");
      return;
    }

    try {
      // Clear any previous uploads
      uppy.cancelAll();

      // Use the modified file if available, otherwise use the original file
      const fileToUpload = modifiedFile || downloadedFile;

      if (!fileToUpload) {
        toast.error("No file available for upload");
        return;
      }

      // Create timestamp for file name
      const timestamp = new Date().getTime();
      const sanitizedName = fileToUpload.name.replace(/[^a-zA-Z0-9.-]/g, "_");

      // Format path according to [projectId]/dataset_[time]_filename.ext
      const path = `${projectId}/dataset_${timestamp}_${sanitizedName}`;

      // Add file to Uppy
      uppy.addFile({
        name: path,
        type: fileToUpload.type,
        data: fileToUpload,
        meta: {
          alias: datasetName,
          datasetName: datasetName,
          projectId,
          type: "dataset",
          description: description || "Imported from URL",
          fileFormat: detectedFormat || "csv",
          originalUrl: url,
          processedWithDuckDB: modifiedFile !== null,
        },
      });

      // Start upload
      uppy.upload();
      setIsConfirmDialogOpen(false);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";
      setUrlError(`Upload preparation failed: ${errorMessage}`);
      toast.error(`Upload preparation failed: ${errorMessage}`);
    }
  };

  const handleClearUrl = () => {
    setUrl("");
    setUrlError(null);
    setDownloadedFile(null);
    setModifiedFile(null);
    setValidationResult(null);
    setDetectedFormat(null);
    resetColumnMappings();
    clearColumnDescriptions();
    if (uppy) {
      uppy.cancelAll();
    }
  };

  const getDefaultDatasetName = () => {
    if (!downloadedFile) return "";
    return downloadedFile.name
      .replace(/\.(csv|txt|json|jsonl|ndjson|tsv|parquet|xlsx)$/, "")
      .replace(/[^a-zA-Z0-9.-]/g, "_");
  };

  // Don't show loading here - it's handled at the wizard level
  if (isInitializing) {
    return null;
  }

  if (duckDbError) {
    toast.error(`DuckDB initialization error: ${duckDbError.message}`);
  }

  return (
    <div className={cn("w-full", className)}>
      {urlError && (
        <Alert variant="destructive" className="mb-4">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>URL Upload Error</AlertTitle>
          <AlertDescription>{urlError}</AlertDescription>
        </Alert>
      )}

      {validationResult && (
        <Alert
          variant={validationResult.isValid ? "default" : "destructive"}
          className="mb-4"
        >
          {validationResult.isValid ? (
            validationResult.error &&
            validationResult.error.includes("too large") ? (
              <AlertCircle className="h-4 w-4 text-blue-500" />
            ) : (
              <CheckCircle2 className="h-4 w-4 text-green-500" />
            )
          ) : (
            <AlertCircle className="h-4 w-4" />
          )}
          <AlertTitle>
            {validationResult.isValid
              ? validationResult.error &&
                validationResult.error.includes("too large")
                ? "Large File Detected"
                : `DuckDB ${getFileFormatDisplay(
                    validationResult.format
                  )} Validation Successful`
              : `DuckDB ${getFileFormatDisplay(
                  validationResult.format
                )} Validation Failed`}
          </AlertTitle>
          <AlertDescription>
            {validationResult.error
              ? validationResult.error
              : validationResult.columnNames && (
                  <div className="mt-2">
                    <p>
                      {getFileFormatDisplay(validationResult.format)} file is
                      valid with {validationResult.columnCount} columns:
                    </p>
                    <p className="text-xs mt-1 max-h-20 overflow-y-auto">
                      {validationResult.columnNames.join(", ")}
                    </p>
                    {validationResult.tables &&
                      validationResult.tables.length > 1 && (
                        <p className="text-sm mt-2 text-blue-500">
                          DuckDB file contains {validationResult.tables.length}{" "}
                          tables: {validationResult.tables.join(", ")}
                        </p>
                      )}
                    {modifiedFile && (
                      <p className="text-sm mt-2 text-blue-500 font-medium">
                        File processed with custom datatypes. The column names
                        will be updated during import.
                      </p>
                    )}
                    {hasDataTypeChanges() &&
                      !modifiedFile &&
                      detectedFormat === "csv" && (
                        <p className="text-sm mt-2 text-amber-500">
                          Datatype changes will be applied on next edit
                        </p>
                      )}
                    {detectedFormat &&
                      !["csv"].includes(detectedFormat) &&
                      hasDataTypeChanges() && (
                        <p className="text-sm mt-2 text-gray-500">
                          Datatype conversion is only available for CSV files
                        </p>
                      )}
                  </div>
                )}
          </AlertDescription>
        </Alert>
      )}

      {/* Display rejected rows warning */}
      {validationResult?.isValid &&
        validationResult.rejectedRowCount &&
        validationResult.rejectedRowCount > 0 && (
          <Alert variant="default" className="mb-4 border-amber-200 bg-amber-50 dark:border-amber-800 dark:bg-amber-950">
            <AlertTriangle className="h-4 w-4 text-amber-600 dark:text-amber-400" />
            <AlertTitle className="text-amber-900 dark:text-amber-100">
              Data Type Validation Warnings
            </AlertTitle>
            <AlertDescription className="text-amber-800 dark:text-amber-200">
              <div className="space-y-2">
                <p>
                  {validationResult.rejectedRowCount} row(s) contain data that
                  doesn&apos;t match the expected types and will be excluded from the
                  dataset:
                </p>
                {validationResult.rejectedRows &&
                  validationResult.rejectedRows.slice(0, 5).map((rejection, index) => {
                    let displayMessage = "";
                    
                    if (rejection.actualValue && rejection.actualValue.trim() !== "") {
                      // Show actual value if it exists and is not just whitespace
                      const actualValue = rejection.actualValue.length > 50 ? 
                        `${rejection.actualValue.substring(0, 50)}...` : 
                        rejection.actualValue;
                      displayMessage = `got '${actualValue}'`;
                    } else {
                      // For empty values, just say "is empty" or "is missing"
                      displayMessage = "is empty";
                    }
                    
                    const displayExpectedType = rejection.expectedType === "unknown" ? 
                      "a valid type" : 
                      rejection.expectedType;
                    
                    return (
                      <div key={index} className="text-xs bg-amber-100 dark:bg-amber-900 p-2 rounded border border-amber-200 dark:border-amber-700">
                        <span className="font-medium">Row {rejection.rowNumber}:</span>{" "}
                        Column &apos;{rejection.columnName}&apos; expected{" "}
                        <span className="font-mono text-amber-700 dark:text-amber-300">{displayExpectedType}</span> but {displayMessage}
                        {rejection.errorMessage !== "Data type mismatch" && (
                          <div className="mt-1 text-amber-600 dark:text-amber-400">
                            {rejection.errorMessage}
                          </div>
                        )}
                      </div>
                    );
                  })}
                {validationResult.rejectedRows &&
                  validationResult.rejectedRows.length > 5 && (
                    <p className="text-xs text-amber-700 dark:text-amber-300">
                      ... and {validationResult.rejectedRows.length - 5} more
                      issue(s)
                    </p>
                  )}
                <p className="text-sm font-medium">
                  You can proceed with the upload (rejected rows will be skipped)
                  or fix the data and try again.
                </p>
              </div>
            </AlertDescription>
          </Alert>
        )}

      {!downloadedFile && !isUploading ? (
        <div className="space-y-4">
          <div className="flex gap-2">
            <div className="flex-1">
              <Input
                type="url"
                placeholder="https://example.com/data.csv"
                value={url}
                onChange={(e) => setUrl(e.target.value)}
                className="w-full"
              />
            </div>
            <Button
              onClick={handleAddUrl}
              disabled={!url.trim() || !isValidUrl(url)}
            >
              <LinkIcon className="h-4 w-4 mr-2" />
              Download
            </Button>
          </div>

          {url && (
            <div className="text-xs text-muted-foreground">
              <p>
                <strong>File:</strong> {getFilenameFromUrl(url)}
              </p>
              <p className="mt-1">
                Make sure the URL points directly to a data file (CSV, JSON,
                etc.) and is publicly accessible.
              </p>
            </div>
          )}
        </div>
      ) : downloadedFile && !isUploading ? (
        <div className="border p-4">
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center">
              <CheckCircle className="h-8 w-8 text-green-500 mr-3" />
              <div>
                <p className="font-medium text-sm">File Ready for Upload</p>
                <p className="text-xs text-muted-foreground">
                  {(modifiedFile || downloadedFile).name} ({((modifiedFile || downloadedFile).size / 1024).toFixed(1)} KB)
                  {detectedFormat && (
                    <span className="ml-2">
                      • {getFileFormatDisplay(detectedFormat)}
                    </span>
                  )}
                </p>
              </div>
            </div>
            <Button
              variant="ghost"
              size="icon"
              onClick={handleClearUrl}
            >
              <X className="h-4 w-4" />
            </Button>
          </div>

          <Button
            className="w-full"
            onClick={() => setIsConfirmDialogOpen(true)}
            disabled={!canUpload}
          >
            {canUpload ? (
              <>
                <CheckCircle className="h-4 w-4 mr-2" />
                Upload Dataset
              </>
            ) : (
              "Fix validation errors"
            )}
          </Button>
        </div>
      ) : (
        <div className="border p-4">
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center">
              <Download className="h-8 w-8 text-primary mr-3" />
              <div>
                <p className="font-medium text-sm">Uploading File</p>
                <p className="text-xs text-muted-foreground truncate max-w-xs">
                  {downloadedFile?.name}
                </p>
              </div>
            </div>
          </div>

          <div className="space-y-2">
            <Progress value={progress} className="h-2" />
            <p className="text-xs text-center text-muted-foreground">
              Uploading: {progress}%
            </p>
          </div>
        </div>
      )}

      {/* Column name editor with datatype processing callback - only show for tabular formats */}
      {validationResult?.isValid &&
        detectedFormat &&
        ["csv", "parquet", "excel"].includes(detectedFormat) && (
          <ColumnNameEditor onDataTypeChange={handleDataTypeChange} />
        )}

      {/* Confirmation Dialog */}
      <UploadConfirmationDialog
        isOpen={isConfirmDialogOpen}
        onClose={() => setIsConfirmDialogOpen(false)}
        onConfirm={handleConfirmUpload}
        defaultName={getDefaultDatasetName()}
        fileName={(modifiedFile || downloadedFile)?.name || ""}
      />
    </div>
  );
}