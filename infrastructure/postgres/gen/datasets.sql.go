// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: datasets.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDataset = `-- name: CreateDataset :one
insert into datasets (
    name,
    description,
    format,
    row_count,
    size,
    file_path,
    columns
) values ($1, $2, $3, $4, $5, $6, $7)
returning id, name, description, format, created_at, updated_at, row_count, size, file_path, columns
`

type CreateDatasetParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Format      string      `json:"format"`
	RowCount    pgtype.Int4 `json:"rowCount"`
	Size        pgtype.Int8 `json:"size"`
	FilePath    string      `json:"filePath"`
	Columns     []byte      `json:"columns"`
}

func (q *Queries) CreateDataset(ctx context.Context, arg CreateDatasetParams) (Dataset, error) {
	row := q.db.QueryRow(ctx, createDataset,
		arg.Name,
		arg.Description,
		arg.Format,
		arg.RowCount,
		arg.Size,
		arg.FilePath,
		arg.Columns,
	)
	var i Dataset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Format,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RowCount,
		&i.Size,
		&i.FilePath,
		&i.Columns,
	)
	return i, err
}

const deleteDataset = `-- name: DeleteDataset :exec
delete from datasets where id = $1
`

func (q *Queries) DeleteDataset(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteDataset, id)
	return err
}

const getDataset = `-- name: GetDataset :one
select id, name, description, format, created_at, updated_at, row_count, size, file_path, columns from datasets where id = $1
`

func (q *Queries) GetDataset(ctx context.Context, id string) (Dataset, error) {
	row := q.db.QueryRow(ctx, getDataset, id)
	var i Dataset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Format,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RowCount,
		&i.Size,
		&i.FilePath,
		&i.Columns,
	)
	return i, err
}

const getDatasetsByIds = `-- name: GetDatasetsByIds :many
select id, name, description, format, created_at, updated_at, row_count, size, file_path, columns from datasets
where id = any($1::uuid[])
`

func (q *Queries) GetDatasetsByIds(ctx context.Context, dollar_1 []pgtype.UUID) ([]Dataset, error) {
	rows, err := q.db.Query(ctx, getDatasetsByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Dataset
	for rows.Next() {
		var i Dataset
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Format,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RowCount,
			&i.Size,
			&i.FilePath,
			&i.Columns,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatasets = `-- name: ListDatasets :many
select id, name, description, format, created_at, updated_at, row_count, size, file_path, columns from datasets
order by created_at desc
limit $1 offset $2
`

type ListDatasetsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListDatasets(ctx context.Context, arg ListDatasetsParams) ([]Dataset, error) {
	rows, err := q.db.Query(ctx, listDatasets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Dataset
	for rows.Next() {
		var i Dataset
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Format,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RowCount,
			&i.Size,
			&i.FilePath,
			&i.Columns,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDatasets = `-- name: SearchDatasets :many
select id, name, description, format, created_at, updated_at, row_count, size, file_path, columns from datasets
where 
    name ilike concat('%', $1, '%') or
    description ilike concat('%', $1, '%') or
    format ilike concat('%', $1, '%') 
order by 
    case 
        when name ilike concat($1, '%') then 1
        when name ilike concat('%', $1, '%') then 2
        else 3
    end,
    created_at desc
limit $2 offset $3
`

type SearchDatasetsParams struct {
	Concat interface{} `json:"concat"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) SearchDatasets(ctx context.Context, arg SearchDatasetsParams) ([]Dataset, error) {
	rows, err := q.db.Query(ctx, searchDatasets, arg.Concat, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Dataset
	for rows.Next() {
		var i Dataset
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Format,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RowCount,
			&i.Size,
			&i.FilePath,
			&i.Columns,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDataset = `-- name: UpdateDataset :one
update datasets
set 
    name = coalesce($1, name),
    description = coalesce($2, description),
    format = coalesce($3, format),
    row_count = coalesce($4, row_count),
    size = coalesce($5, size),
    file_path = coalesce($6, file_path),
    columns = coalesce($7, columns)
where id = $8
returning id, name, description, format, created_at, updated_at, row_count, size, file_path, columns
`

type UpdateDatasetParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Format      string      `json:"format"`
	RowCount    pgtype.Int4 `json:"rowCount"`
	Size        pgtype.Int8 `json:"size"`
	FilePath    string      `json:"filePath"`
	Columns     []byte      `json:"columns"`
	ID          string      `json:"id"`
}

func (q *Queries) UpdateDataset(ctx context.Context, arg UpdateDatasetParams) (Dataset, error) {
	row := q.db.QueryRow(ctx, updateDataset,
		arg.Name,
		arg.Description,
		arg.Format,
		arg.RowCount,
		arg.Size,
		arg.FilePath,
		arg.Columns,
		arg.ID,
	)
	var i Dataset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Format,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RowCount,
		&i.Size,
		&i.FilePath,
		&i.Columns,
	)
	return i, err
}

const updateDatasetColumns = `-- name: UpdateDatasetColumns :one
update datasets
set columns = $1
where id = $2
returning id, name, description, format, created_at, updated_at, row_count, size, file_path, columns
`

type UpdateDatasetColumnsParams struct {
	Columns []byte `json:"columns"`
	ID      string `json:"id"`
}

func (q *Queries) UpdateDatasetColumns(ctx context.Context, arg UpdateDatasetColumnsParams) (Dataset, error) {
	row := q.db.QueryRow(ctx, updateDatasetColumns, arg.Columns, arg.ID)
	var i Dataset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Format,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RowCount,
		&i.Size,
		&i.FilePath,
		&i.Columns,
	)
	return i, err
}

const updateDatasetPath = `-- name: UpdateDatasetPath :one
update datasets
set file_path = $1
where id = $2
returning id, name, description, format, created_at, updated_at, row_count, size, file_path, columns
`

type UpdateDatasetPathParams struct {
	FilePath string `json:"filePath"`
	ID       string `json:"id"`
}

func (q *Queries) UpdateDatasetPath(ctx context.Context, arg UpdateDatasetPathParams) (Dataset, error) {
	row := q.db.QueryRow(ctx, updateDatasetPath, arg.FilePath, arg.ID)
	var i Dataset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Format,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RowCount,
		&i.Size,
		&i.FilePath,
		&i.Columns,
	)
	return i, err
}

const updateDatasetStats = `-- name: UpdateDatasetStats :one

update datasets
set 
    row_count = $1,
    size = $2
where id = $3
returning id, name, description, format, created_at, updated_at, row_count, size, file_path, columns
`

type UpdateDatasetStatsParams struct {
	RowCount pgtype.Int4 `json:"rowCount"`
	Size     pgtype.Int8 `json:"size"`
	ID       string      `json:"id"`
}

// You might also want these additional queries:
func (q *Queries) UpdateDatasetStats(ctx context.Context, arg UpdateDatasetStatsParams) (Dataset, error) {
	row := q.db.QueryRow(ctx, updateDatasetStats, arg.RowCount, arg.Size, arg.ID)
	var i Dataset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Format,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RowCount,
		&i.Size,
		&i.FilePath,
		&i.Columns,
	)
	return i, err
}
