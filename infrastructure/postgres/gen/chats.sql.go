// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: chats.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createChat = `-- name: CreateChat :one
insert into chats (
    name,
    description,
    dataset_id,
    created_by,
    updated_by
) values ($1, $2, $3, $4, $5)
returning id, name, description, dataset_id, created_at, updated_at, created_by, updated_by
`

type CreateChatParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	DatasetID   pgtype.UUID `json:"datasetId"`
	CreatedBy   pgtype.Text `json:"createdBy"`
	UpdatedBy   pgtype.Text `json:"updatedBy"`
}

func (q *Queries) CreateChat(ctx context.Context, arg CreateChatParams) (Chat, error) {
	row := q.db.QueryRow(ctx, createChat,
		arg.Name,
		arg.Description,
		arg.DatasetID,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.DatasetID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const createChatMessage = `-- name: CreateChatMessage :one
insert into chat_messages (
    chat_id,
    content,
    role,
    created_by
) values ($1, $2, $3, $4)
returning id, chat_id, content, role, created_at, created_by
`

type CreateChatMessageParams struct {
	ChatID    pgtype.UUID `json:"chatId"`
	Content   string      `json:"content"`
	Role      string      `json:"role"`
	CreatedBy pgtype.Text `json:"createdBy"`
}

// Chat Messages Operations
func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.ChatID,
		arg.Content,
		arg.Role,
		arg.CreatedBy,
	)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.Content,
		&i.Role,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteAllChatMessages = `-- name: DeleteAllChatMessages :exec
delete from chat_messages where chat_id = $1
`

func (q *Queries) DeleteAllChatMessages(ctx context.Context, chatID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllChatMessages, chatID)
	return err
}

const deleteChat = `-- name: DeleteChat :exec
delete from chats where id = $1
`

func (q *Queries) DeleteChat(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteChat, id)
	return err
}

const deleteChatMessage = `-- name: DeleteChatMessage :exec
delete from chat_messages where id = $1
`

func (q *Queries) DeleteChatMessage(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteChatMessage, id)
	return err
}

const getChat = `-- name: GetChat :one
select 
    c.id, c.name, c.description, c.dataset_id, c.created_at, c.updated_at, c.created_by, c.updated_by,
    d.name as dataset_name,
    (select count(*) from chat_messages where chat_id = c.id) as message_count
from chats c
join datasets d on c.dataset_id = d.id
where c.id = $1
`

type GetChatRow struct {
	ID           pgtype.UUID        `json:"id"`
	Name         string             `json:"name"`
	Description  pgtype.Text        `json:"description"`
	DatasetID    pgtype.UUID        `json:"datasetId"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt    pgtype.Timestamptz `json:"updatedAt"`
	CreatedBy    pgtype.Text        `json:"createdBy"`
	UpdatedBy    pgtype.Text        `json:"updatedBy"`
	DatasetName  string             `json:"datasetName"`
	MessageCount int64              `json:"messageCount"`
}

func (q *Queries) GetChat(ctx context.Context, id pgtype.UUID) (GetChatRow, error) {
	row := q.db.QueryRow(ctx, getChat, id)
	var i GetChatRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.DatasetID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DatasetName,
		&i.MessageCount,
	)
	return i, err
}

const getChatMessage = `-- name: GetChatMessage :one
select id, chat_id, content, role, created_at, created_by from chat_messages where id = $1
`

func (q *Queries) GetChatMessage(ctx context.Context, id pgtype.UUID) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, getChatMessage, id)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.Content,
		&i.Role,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getChatMessagesCount = `-- name: GetChatMessagesCount :one
select count(*) 
from chat_messages
where chat_id = $1
`

func (q *Queries) GetChatMessagesCount(ctx context.Context, chatID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getChatMessagesCount, chatID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getDatasetChatsCount = `-- name: GetDatasetChatsCount :one
select count(*) 
from chats
where dataset_id = $1
`

func (q *Queries) GetDatasetChatsCount(ctx context.Context, datasetID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getDatasetChatsCount, datasetID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLatestChatMessage = `-- name: GetLatestChatMessage :one
select id, chat_id, content, role, created_at, created_by from chat_messages
where chat_id = $1
order by created_at desc
limit 1
`

func (q *Queries) GetLatestChatMessage(ctx context.Context, chatID pgtype.UUID) (ChatMessage, error) {
	row := q.db.QueryRow(ctx, getLatestChatMessage, chatID)
	var i ChatMessage
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.Content,
		&i.Role,
		&i.CreatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getUserChats = `-- name: GetUserChats :many
select 
    c.id, c.name, c.description, c.dataset_id, c.created_at, c.updated_at, c.created_by, c.updated_by,
    d.name as dataset_name,
    (select count(*) from chat_messages where chat_id = c.id) as message_count
from chats c
join datasets d on c.dataset_id = d.id
where c.created_by = $1
order by c.updated_at desc
limit $2 offset $3
`

type GetUserChatsParams struct {
	CreatedBy pgtype.Text `json:"createdBy"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

type GetUserChatsRow struct {
	ID           pgtype.UUID        `json:"id"`
	Name         string             `json:"name"`
	Description  pgtype.Text        `json:"description"`
	DatasetID    pgtype.UUID        `json:"datasetId"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt    pgtype.Timestamptz `json:"updatedAt"`
	CreatedBy    pgtype.Text        `json:"createdBy"`
	UpdatedBy    pgtype.Text        `json:"updatedBy"`
	DatasetName  string             `json:"datasetName"`
	MessageCount int64              `json:"messageCount"`
}

func (q *Queries) GetUserChats(ctx context.Context, arg GetUserChatsParams) ([]GetUserChatsRow, error) {
	rows, err := q.db.Query(ctx, getUserChats, arg.CreatedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserChatsRow
	for rows.Next() {
		var i GetUserChatsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.DatasetID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DatasetName,
			&i.MessageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserChatsCount = `-- name: GetUserChatsCount :one
select count(*) 
from chats
where created_by = $1
`

func (q *Queries) GetUserChatsCount(ctx context.Context, createdBy pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, getUserChatsCount, createdBy)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listChatMessages = `-- name: ListChatMessages :many
select id, chat_id, content, role, created_at, created_by from chat_messages
where chat_id = $1
order by created_at asc
limit $2 offset $3
`

type ListChatMessagesParams struct {
	ChatID pgtype.UUID `json:"chatId"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListChatMessages(ctx context.Context, arg ListChatMessagesParams) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, listChatMessages, arg.ChatID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.Content,
			&i.Role,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatasetChats = `-- name: ListDatasetChats :many
select 
    c.id, c.name, c.description, c.dataset_id, c.created_at, c.updated_at, c.created_by, c.updated_by,
    (select count(*) from chat_messages where chat_id = c.id) as message_count
from chats c
where c.dataset_id = $1
order by c.updated_at desc
limit $2 offset $3
`

type ListDatasetChatsParams struct {
	DatasetID pgtype.UUID `json:"datasetId"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

type ListDatasetChatsRow struct {
	ID           pgtype.UUID        `json:"id"`
	Name         string             `json:"name"`
	Description  pgtype.Text        `json:"description"`
	DatasetID    pgtype.UUID        `json:"datasetId"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt    pgtype.Timestamptz `json:"updatedAt"`
	CreatedBy    pgtype.Text        `json:"createdBy"`
	UpdatedBy    pgtype.Text        `json:"updatedBy"`
	MessageCount int64              `json:"messageCount"`
}

func (q *Queries) ListDatasetChats(ctx context.Context, arg ListDatasetChatsParams) ([]ListDatasetChatsRow, error) {
	rows, err := q.db.Query(ctx, listDatasetChats, arg.DatasetID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDatasetChatsRow
	for rows.Next() {
		var i ListDatasetChatsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.DatasetID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.MessageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchChats = `-- name: SearchChats :many
select 
    c.id, c.name, c.description, c.dataset_id, c.created_at, c.updated_at, c.created_by, c.updated_by,
    d.name as dataset_name,
    (select count(*) from chat_messages where chat_id = c.id) as message_count
from chats c
join datasets d on c.dataset_id = d.id
where 
    c.name ilike concat('%', $1, '%') or
    c.description ilike concat('%', $1, '%')
order by 
    case 
        when c.name ilike concat($1, '%') then 1
        when c.name ilike concat('%', $1, '%') then 2
        else 3
    end,
    c.updated_at desc
limit $2 offset $3
`

type SearchChatsParams struct {
	Concat interface{} `json:"concat"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type SearchChatsRow struct {
	ID           pgtype.UUID        `json:"id"`
	Name         string             `json:"name"`
	Description  pgtype.Text        `json:"description"`
	DatasetID    pgtype.UUID        `json:"datasetId"`
	CreatedAt    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt    pgtype.Timestamptz `json:"updatedAt"`
	CreatedBy    pgtype.Text        `json:"createdBy"`
	UpdatedBy    pgtype.Text        `json:"updatedBy"`
	DatasetName  string             `json:"datasetName"`
	MessageCount int64              `json:"messageCount"`
}

func (q *Queries) SearchChats(ctx context.Context, arg SearchChatsParams) ([]SearchChatsRow, error) {
	rows, err := q.db.Query(ctx, searchChats, arg.Concat, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchChatsRow
	for rows.Next() {
		var i SearchChatsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.DatasetID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DatasetName,
			&i.MessageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChat = `-- name: UpdateChat :one
update chats
set 
    name = coalesce($1, name),
    description = coalesce($2, description),
    updated_by = coalesce($3, updated_by)
where id = $4
returning id, name, description, dataset_id, created_at, updated_at, created_by, updated_by
`

type UpdateChatParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	UpdatedBy   pgtype.Text `json:"updatedBy"`
	ID          pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateChat(ctx context.Context, arg UpdateChatParams) (Chat, error) {
	row := q.db.QueryRow(ctx, updateChat,
		arg.Name,
		arg.Description,
		arg.UpdatedBy,
		arg.ID,
	)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.DatasetID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}
